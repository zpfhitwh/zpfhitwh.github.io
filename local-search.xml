<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>myLeetCodeLog</title>
    <link href="/2025/11/05/myLeetCodeLog/"/>
    <url>/2025/11/05/myLeetCodeLog/</url>
    
    <content type="html"><![CDATA[<h1 id="记录刷题的一些简单体会与心得"><a href="#记录刷题的一些简单体会与心得" class="headerlink" title="记录刷题的一些简单体会与心得"></a>记录刷题的一些简单体会与心得</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>主要结合双指针，可以将一些问题的算法复杂度降低，思想是让两个指针同时操作，代替原始的遍历操作。</p><h3 id="判断回文链表"><a href="#判断回文链表" class="headerlink" title="判断回文链表"></a>判断回文链表</h3><p>这里我是通过快慢指针与栈的操作结合，让快指针速度为慢指针两倍，移动的同时将慢指针指向的值压入栈。快指针移动完之后，继续移动慢指针并比较栈顶元素与当前值，若相同则弹出栈顶元素。最后若栈为空则说明回文。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        stack&lt;<span class="hljs-type">int</span>&gt; temp;<br><br>        <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">nullptr</span>)&#123;<br>            size++;<br>            fast = fast-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(size==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(size==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(size==<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> (head-&gt;val == head-&gt;next-&gt;val);<br>        &#125;<br><br>        fast = head;<br><br>        <span class="hljs-keyword">if</span> (size%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">while</span>(fast-&gt;next-&gt;next !=<span class="hljs-literal">nullptr</span>)&#123;<br>                temp.<span class="hljs-built_in">push</span>(slow-&gt;val);<br>                slow = slow-&gt;next;<br>                fast = fast-&gt;next-&gt;next;<br>            &#125;<br>            temp.<span class="hljs-built_in">push</span>(slow-&gt;val);<br>            slow = slow-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(size%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">while</span>(fast-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;<br>                temp.<span class="hljs-built_in">push</span>(slow-&gt;val);<br>                slow = slow-&gt;next;<br>                fast = fast-&gt;next-&gt;next;<br>            &#125;<br>            slow = slow-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span>(slow!=<span class="hljs-literal">nullptr</span>)&#123;<br>            <br>            <br>            <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">top</span>()!=(slow-&gt;val))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(temp.<span class="hljs-built_in">top</span>()==(slow-&gt;val))&#123;<br>                temp.<span class="hljs-built_in">pop</span>();<br>                slow=slow-&gt;next;<br><br>            &#125;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> temp.<span class="hljs-built_in">empty</span>();<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>先进后出，后进先出，栈顶操作；依赖数组（顺序栈）或者链表（链式栈）实现。</p><p>c++的栈可以直接通过标准库中的stack容器适配器实现，栈的底层是数组或者链表，换言之，通过在数组或链表当中添加额外的方法就可以实现栈的功能特性。于是手敲了栈的底层实现：</p><h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 顺序栈 对应标准库中的stack</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">MyStack</span>()&#123;<br>mtop = <span class="hljs-number">0</span>;<br>mcap = <span class="hljs-number">1</span>;<br>mystack = mystack = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[mcap];<br>&#125;<br><span class="hljs-built_in">MyStack</span>(<span class="hljs-type">int</span> size) :<br><span class="hljs-built_in">mtop</span>(<span class="hljs-number">0</span>),<br><span class="hljs-built_in">mcap</span>(size)&#123;<br>mystack = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[mcap];<br>&#125;<br><br>~<span class="hljs-built_in">MyStack</span>() &#123;<br><span class="hljs-keyword">delete</span>[]mystack;<br>mystack = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 入栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (mtop == mcap) &#123;<br><span class="hljs-built_in">expand</span>(<span class="hljs-number">2</span> * mcap);<br>&#125;<br>mystack[mtop] = val;<br>mtop++;<br>&#125;<br><br><span class="hljs-comment">// 出栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (mtop == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">throw</span><span class="hljs-string">&quot;Stack is empty!&quot;</span>;<br>&#125;<br>mtop--;<br>&#125;<br><br><span class="hljs-comment">// 获取栈顶元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br><span class="hljs-keyword">if</span> (mtop == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">throw</span><span class="hljs-string">&quot;Stack is empty!&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> mystack[mtop<span class="hljs-number">-1</span>];<br>&#125;<br><br><span class="hljs-comment">// 判断栈是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><br><span class="hljs-keyword">return</span> mtop == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 获取栈元素个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> mtop; &#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 扩容</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">expand</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> </span>&#123;<br><span class="hljs-type">int</span>* p = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size];<br><span class="hljs-built_in">memcpy</span>(p, mystack, mtop*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br><span class="hljs-keyword">delete</span>[]mystack;<br>mystack = p;<br>mcap = size;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span>* mystack;<br><span class="hljs-type">int</span> mtop; <span class="hljs-comment">// 栈顶位置</span><br><span class="hljs-type">int</span> mcap; <span class="hljs-comment">// 栈的大小</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 链式栈</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">LinkStack</span>() :<span class="hljs-built_in">length</span>(<span class="hljs-number">0</span>) &#123;<br>head = <span class="hljs-keyword">new</span> Node;<br>&#125;<br>~<span class="hljs-built_in">LinkStack</span>() &#123;<br>Node* p = head;<br><span class="hljs-keyword">while</span> (p != <span class="hljs-literal">nullptr</span>) &#123;<br>head = head-&gt;next;<br><span class="hljs-keyword">delete</span> p;<br>p = head;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 入栈 链表头节点后面第一个有效节点的位置作为栈顶位置</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>Node* node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(val);<br>node-&gt;next = head-&gt;next;<br>head-&gt;next = node;<br>length++;<br>&#125;<br><br><span class="hljs-comment">// 出栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br><span class="hljs-keyword">throw</span><span class="hljs-string">&quot;stack is empty!&quot;</span>;<br>&#125;<br>Node* p = head-&gt;next;<br>head-&gt;next = p-&gt;next;<br><span class="hljs-keyword">delete</span> p;<br>length--;<br>&#125;<br><br><span class="hljs-comment">// 获取栈顶元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br><span class="hljs-keyword">throw</span><span class="hljs-string">&quot;stack is empty!&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> head-&gt;next-&gt;data;<br>&#125;<br><br><span class="hljs-comment">// 判断是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br><span class="hljs-keyword">return</span> head-&gt;next == <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-comment">// 返回栈元素个数 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> length;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> val = <span class="hljs-number">0</span>):<span class="hljs-built_in">data</span>(val), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br><span class="hljs-type">int</span> data;<br>Node* next;<br>&#125;;<br>Node* head;<br><span class="hljs-type">int</span> length; <span class="hljs-comment">// 栈元素个数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>到目前为止体会到的是，算法更多的还是在于对指针的理解。</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>先进先出、后进后出，依靠数组或者链表实现。</p><h3 id="两个栈实现一个队列"><a href="#两个栈实现一个队列" class="headerlink" title="两个栈实现一个队列"></a>两个栈实现一个队列</h3><p>LeetCode 第232题，拿来练手，加深理解。</p><p>顺便利用this指针实现代码复用，加强对this指针的理解。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> &#123;</span><br>public:<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-type">int</span>&gt; stIn;<br>    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-type">int</span>&gt; stOut;<br><br>    MyQueue() &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-type">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        stIn.push(x);<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(stOut.empty())&#123;<br>            <span class="hljs-keyword">while</span>(!stIn.empty())&#123;<br>                stOut.push(stIn.top());<br>                stIn.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> p = stOut.top();<br>        stOut.pop();<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">peek</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> t = this-&gt;pop();<br>        stOut.push(t);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <br>    <span class="hljs-type">bool</span> <span class="hljs-title function_">empty</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span>(stIn.empty() &amp;&amp; stOut.empty());<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue* obj = new MyQueue();</span><br><span class="hljs-comment"> * obj-&gt;push(x);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;peek();</span><br><span class="hljs-comment"> * bool param_4 = obj-&gt;empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="两个队列实现一个栈"><a href="#两个队列实现一个栈" class="headerlink" title="两个队列实现一个栈"></a>两个队列实现一个栈</h3><p>跟两个栈的思路不一样，第二个队列只是用来备份。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; q1;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q2; <span class="hljs-comment">// 用于备份</span><br>    <span class="hljs-built_in">MyStack</span>() &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        q<span class="hljs-number">1.</span><span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> size = q<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>();<br>        size--;<br>        <span class="hljs-keyword">while</span>((q<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>())!=<span class="hljs-number">1</span>)&#123;<br>            q<span class="hljs-number">2.</span><span class="hljs-built_in">push</span>(q<span class="hljs-number">1.f</span>ront());<br>            q<span class="hljs-number">1.</span><span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-type">int</span> t = q<span class="hljs-number">1.f</span>ront();<br>        q<span class="hljs-number">1.</span><span class="hljs-built_in">pop</span>();<br>        q1 = q2;<br>        <span class="hljs-keyword">while</span>(!q<span class="hljs-number">2.</span><span class="hljs-built_in">empty</span>())&#123;<br>            q<span class="hljs-number">2.</span><span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> q<span class="hljs-number">1.</span><span class="hljs-built_in">back</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> q<span class="hljs-number">1.</span><span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyStack* obj = new MyStack();</span><br><span class="hljs-comment"> * obj-&gt;push(x);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"> * bool param_4 = obj-&gt;empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="一个队列实现一个栈"><a href="#一个队列实现一个栈" class="headerlink" title="一个队列实现一个栈"></a>一个队列实现一个栈</h3><p>模拟栈弹出元素的时候，只需要把队列除了最后一个元素之外的元素插入队列尾部即可。</p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>转码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Astron-agent</title>
    <link href="/2025/11/05/Astron-agent/"/>
    <url>/2025/11/05/Astron-agent/</url>
    
    <content type="html"><![CDATA[<h1 id="astron-Agent"><a href="#astron-Agent" class="headerlink" title="astron-Agent"></a>astron-Agent</h1><h2 id="1-环境配置与项目搭建（本地Windows11系统）"><a href="#1-环境配置与项目搭建（本地Windows11系统）" class="headerlink" title="1.环境配置与项目搭建（本地Windows11系统）"></a>1.环境配置与项目搭建（本地Windows11系统）</h2><p>按照微信公众号的步骤进行配置</p><blockquote><p><a href="https://mp.weixin.qq.com/s/QKp2nTKGl0m8JTytc-0ibA?scene=1&click_id=1">https://mp.weixin.qq.com/s/QKp2nTKGl0m8JTytc-0ibA?scene=1&amp;click_id=1</a></p></blockquote><p><em>注：首先要在本地电脑上配置git工具与Docker容器，并且后续命令都在git bash中执行。</em></p><p>配置过程中遇到的几个问题</p><ol><li>在用Docker容器拉取镜像时，一直报错显示</li></ol>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unauthorized:email must be verified before using account<br></code></pre></td></tr></table></figure><p>最后发现是由于注册Docker账号时，官方会向注册邮箱中发送邮件，在邮件中确认之后问题解决。</p><ol start="2"><li>拉取完镜像之后，在Docker容器当中可以看到所有的镜像以及状态，发现<em>astron-agent-casdoor</em>容器一直显示”Restaring(2)”，并且本地进入不了localhost网址。检查到该容器报错为</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">/entrypoint.sh: <span class="hljs-keyword">set</span>: <span class="hljs-type">line</span> <span class="hljs-number">2</span>: illegal <span class="hljs-keyword">option</span> - <br></code></pre></td></tr></table></figure><p>经检查，发现是因为脚本如果实在window环境下创建的，可能包含\r换行符，需要用以下命令将 <em>“D:\astron-agent\astron-agent\docker\astronAgent\casdoor\entrypoint.sh”</em> 目录下的文件转换为Unix格式，在该目录下的git bash中运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sed -i <span class="hljs-string">&#x27;s/\r$//&#x27;</span> entrypoint.sh<br></code></pre></td></tr></table></figure><p>然后再重新拉取镜像，可以发现所有的镜像状态均为runing。</p><p>于是可以直接访问以下网址，启动 Casdoor 管理界面与Agent前端页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs b">#1. http://localhost:8000/<br>#2. http://localhost/<br>用户名：admin<br>密码：123<br></code></pre></td></tr></table></figure><p>界面如下：</p><img src="/2025/11/05/Astron-agent/image-20251030165004319.png"  alt="image-20251030165004319" style="zoom: 25%;" /><img src="/2025/11/05/Astron-agent/image-20251030165038670.png"  alt="image-20251030165038670" style="zoom: 25%;" /><h2 id="2-创建智能体"><a href="#2-创建智能体" class="headerlink" title="2.创建智能体"></a>2.创建智能体</h2><p>创建智能体之后，可以实现智能体的部署且可以进行文本提问与回答，</p><img src="/2025/11/05/Astron-agent/image-20251030181239606.png"  alt="image-20251030181239606" style="zoom:25%;" /><p>存在的问题是，<strong>无法设置头像</strong></p><h3 id="部署本地第三方大模型"><a href="#部署本地第三方大模型" class="headerlink" title="部署本地第三方大模型"></a>部署本地第三方大模型</h3><img src="/2025/11/05/Astron-agent/image-20251030182511016.png"  alt="image-20251030182511016" style="zoom:25%;" /><blockquote><p>接口地址：<a href="https://api.deepseek.com/v1">https://api.deepseek.com/v1</a><br>apiKey自己申请，这里用的deepseek，需要先充钱，不然显示创建失败</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>AI</category>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>agent</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
